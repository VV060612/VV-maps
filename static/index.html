<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VV Maps - æ™ºèƒ½äº¤é€šå¯¼èˆªç³»ç»Ÿ</title>
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/element-plus/2.4.3/index.css" />
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; }
        #app { height: 100%; display: flex; flex-direction: column; }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .header {
            background: #fff;
            box-shadow: 0 2px 12px 0 rgba(0,0,0,0.1);
            z-index: 1000;
            padding: 0 20px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .logo { font-size: 20px; font-weight: bold; color: #409EFF; display: flex; align-items: center; }
        .logo i { margin-right: 10px; font-size: 24px; }

        /* ä¸»ä½“å¸ƒå±€ */
        .main-container { flex: 1; position: relative; overflow: hidden; }

        /* åœ°å›¾å®¹å™¨ */
        #map-container { width: 100%; height: 100%; background: #e0e0e0; z-index: 1; }

        /* æ‚¬æµ®æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 400px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 999;
            padding: 20px;
            transition: all 0.3s;
        }

        /* äº¤é€šæ–¹å¼é€‰æ‹©å™¨ */
        .mode-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        .mode-btn {
            padding: 8px 16px;
            border: 1px solid #dcdfe6;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .mode-btn:hover { border-color: #409EFF; color: #409EFF; }
        .mode-btn.active { background: #409EFF; color: white; border-color: #409EFF; }

        /* è·¯å¾„ç»“æœå¡ç‰‡ */
        .result-card {
            margin-top: 20px;
            border-top: 1px solid #ebeef5;
            padding-top: 15px;
        }
        .result-summary {
            display: flex;
            justify-content: space-around;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 15px;
            color: white;
            margin-bottom: 15px;
        }
        .result-summary-item { text-align: center; }
        .result-summary-item .value { font-size: 24px; font-weight: bold; }
        .result-summary-item .label { font-size: 12px; opacity: 0.9; }

        /* è·¯å¾„æ­¥éª¤ */
        .path-segment {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #409EFF;
        }
        .path-segment.walk { border-left-color: #67C23A; }
        .path-segment.bus { border-left-color: #E6A23C; }
        .path-segment.subway { border-left-color: #F56C6C; }
        .path-segment.bike { border-left-color: #909399; }
        .path-segment.car { border-left-color: #409EFF; }

        .segment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .segment-mode {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            color: white;
        }
        .segment-mode.walk { background: #67C23A; }
        .segment-mode.bus { background: #E6A23C; }
        .segment-mode.subway { background: #F56C6C; }
        .segment-mode.bike { background: #909399; }
        .segment-mode.car { background: #409EFF; }

        .segment-info { font-size: 13px; color: #606266; }
        .segment-time { font-size: 12px; color: #909399; }

        /* è·¯çº¿é¢œè‰²å›¾ä¾‹ */
        .route-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 12px 0;
            padding: 10px;
            background: #f5f7fa;
            border-radius: 8px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #606266;
        }
        .legend-color {
            width: 16px;
            height: 4px;
            border-radius: 2px;
            margin-right: 4px;
        }

        /* ç™»å½•å¼¹çª—ç¾åŒ– */
        .login-box { text-align: center; }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        .control-panel::-webkit-scrollbar { width: 6px; }
        .control-panel::-webkit-scrollbar-thumb { background: #c0c4cc; border-radius: 3px; }
        .control-panel::-webkit-scrollbar-track { background: #f5f7fa; }

        /* ç™¾åº¦åœ°å›¾é£æ ¼çš„èµ·ç‚¹ç»ˆç‚¹æ ‡è®° */
        .marker-start, .marker-end {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            font-size: 12px;
            font-weight: bold;
            color: white;
            border: 2px solid white;
        }
        .marker-start {
            background: linear-gradient(180deg, #34d058 0%, #28a745 100%);
        }
        .marker-end {
            background: linear-gradient(180deg, #ff6b6b 0%, #ee5a5a 100%);
        }
        /* èµ·ç‚¹ç»ˆç‚¹ä¸‹æ–¹çš„å°ä¸‰è§’æŒ‡ç¤º */
        .marker-pointer {
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
        }
        .marker-start .marker-pointer {
            border-top: 6px solid #28a745;
        }
        .marker-end .marker-pointer {
            border-top: 6px solid #ee5a5a;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <div class="logo">
                <el-icon><LocationFilled /></el-icon> VV Maps æ™ºèƒ½å¯¼èˆª
            </div>
            <div>
                <el-button v-if="!isLoggedIn" type="primary" plain @click="showLogin = true">ç™»å½• / æ³¨å†Œ</el-button>
                <el-dropdown v-else>
                    <span class="el-dropdown-link" style="cursor: pointer; color: #409EFF;">
                        {{ username }} <el-icon class="el-icon--right"><ArrowDown /></el-icon>
                    </span>
                    <template #dropdown>
                        <el-dropdown-menu>
                            <el-dropdown-item>ä¸ªäººä¸­å¿ƒ</el-dropdown-item>
                            <el-dropdown-item divided @click="handleLogout">é€€å‡ºç™»å½•</el-dropdown-item>
                        </el-dropdown-menu>
                    </template>
                </el-dropdown>
            </div>
        </div>

        <div class="main-container">
            <div class="control-panel">
                <el-tabs v-model="activeTab">
                    <el-tab-pane label="è·¯å¾„è§„åˆ’" name="path">
                        <el-form :model="pathForm" label-width="50px">
                            <el-form-item label="èµ·ç‚¹">
                                <el-select
                                    v-model="pathForm.start"
                                    filterable
                                    placeholder="è¯·é€‰æ‹©æˆ–æœç´¢èµ·ç‚¹"
                                    style="width: 100%"
                                    @change="onStartChange">
                                    <el-option
                                        v-for="item in allNodes"
                                        :key="item.id"
                                        :label="item.name"
                                        :value="item.id">
                                        <span>{{ item.name }}</span>
                                        <span style="float: right; color: #8492a6; font-size: 12px">{{ getTypeLabel(item.type) }}</span>
                                    </el-option>
                                </el-select>
                            </el-form-item>
                            <el-form-item label="ç»ˆç‚¹">
                                <el-select
                                    v-model="pathForm.end"
                                    filterable
                                    placeholder="è¯·é€‰æ‹©æˆ–æœç´¢ç»ˆç‚¹"
                                    style="width: 100%"
                                    @change="onEndChange">
                                    <el-option
                                        v-for="item in allNodes"
                                        :key="item.id"
                                        :label="item.name"
                                        :value="item.id">
                                        <span>{{ item.name }}</span>
                                        <span style="float: right; color: #8492a6; font-size: 12px">{{ getTypeLabel(item.type) }}</span>
                                    </el-option>
                                </el-select>
                            </el-form-item>

                            <el-form-item label="æ–¹å¼">
                                <div class="mode-selector">
                                    <div
                                        class="mode-btn"
                                        :class="{ active: pathForm.modes.includes('walk') }"
                                        @click="toggleMode('walk')">
                                        ğŸš¶ æ­¥è¡Œ
                                    </div>
                                    <div
                                        class="mode-btn"
                                        :class="{ active: pathForm.modes.includes('bike') }"
                                        @click="toggleMode('bike')">
                                        ğŸš² éª‘è¡Œ
                                    </div>
                                    <div
                                        class="mode-btn"
                                        :class="{ active: pathForm.modes.includes('car') }"
                                        @click="toggleMode('car')">
                                        ğŸš— é©¾è½¦
                                    </div>
                                    <div
                                        class="mode-btn"
                                        :class="{ active: pathForm.modes.includes('bus') }"
                                        @click="toggleMode('bus')">
                                        ğŸšŒ å…¬äº¤
                                    </div>
                                    <div
                                        class="mode-btn"
                                        :class="{ active: pathForm.modes.includes('subway') }"
                                        @click="toggleMode('subway')">
                                        ğŸš‡ åœ°é“
                                    </div>
                                </div>
                            </el-form-item>

                            <el-button type="primary" style="width: 100%; margin-top: 10px;" @click="findPath" :loading="calculating">
                                <el-icon style="margin-right: 5px"><Search /></el-icon> å¼€å§‹å¯¼èˆª
                            </el-button>
                        </el-form>

                        <div v-if="pathResult" class="result-card">
                            <div class="result-summary">
                                <div class="result-summary-item">
                                    <div class="value">{{ formatTime(pathResult.estimated_time) }}</div>
                                    <div class="label">é¢„è®¡è€—æ—¶</div>
                                </div>
                                <div class="result-summary-item">
                                    <div class="value">{{ formatDistance(pathResult.distance) }}</div>
                                    <div class="label">æ€»è·ç¦»</div>
                                </div>
                            </div>

                            <!-- è·¯çº¿é¢œè‰²å›¾ä¾‹ -->
                            <div class="route-legend">
                                <span class="legend-item"><span class="legend-color" style="background:#67C23A;"></span>æ­¥è¡Œ</span>
                                <span class="legend-item"><span class="legend-color" style="background:#909399;"></span>éª‘è¡Œ</span>
                                <span class="legend-item"><span class="legend-color" style="background:#409EFF;"></span>é©¾è½¦</span>
                                <span class="legend-item"><span class="legend-color" style="background:#E6A23C;"></span>å…¬äº¤</span>
                                <span class="legend-item"><span class="legend-color" style="background:#F56C6C;"></span>åœ°é“</span>
                            </div>

                            <div style="font-weight: bold; margin-bottom: 10px; color: #303133;">
                                <el-icon><Guide /></el-icon> è·¯çº¿è¯¦æƒ…
                            </div>

                            <div v-for="(seg, index) in pathResult.segments" :key="index"
                                 class="path-segment" :class="seg.used_mode">
                                <div class="segment-header">
                                    <span class="segment-mode" :class="seg.used_mode">
                                        {{ getModeIcon(seg.used_mode) }} {{ getModeLabel(seg.used_mode) }}
                                    </span>
                                    <span class="segment-time">{{ formatTime(seg.time) }}</span>
                                </div>
                                <div class="segment-info">
                                    {{ seg.from_name }} â†’ {{ seg.to_name }}
                                </div>
                                <div class="segment-time">
                                    {{ formatDistance(seg.distance) }}
                                    <span v-if="seg.line_id"> Â· {{ seg.line_id }}</span>
                                </div>
                            </div>
                        </div>
                    </el-tab-pane>

                    <el-tab-pane label="èŠ‚ç‚¹æŸ¥è¯¢" name="node">
                        <el-input
                            placeholder="è¾“å…¥å…³é”®è¯æœç´¢èŠ‚ç‚¹..."
                            v-model="nodeSearchInput"
                            @keyup.enter="searchNodesByName"
                            clearable>
                            <template #append>
                                <el-button @click="searchNodesByName"><el-icon><Search /></el-icon></el-button>
                            </template>
                        </el-input>

                        <div v-if="searchResults.length > 0" style="margin-top: 15px;">
                            <div v-for="node in searchResults" :key="node.id"
                                 style="padding: 10px; border-bottom: 1px solid #ebeef5; cursor: pointer;"
                                 @click="focusNode(node)">
                                <div style="font-weight: bold; color: #303133;">{{ node.name }}</div>
                                <div style="font-size: 12px; color: #909399;">
                                    {{ getTypeLabel(node.type) }} Â· ID: {{ node.id }}
                                </div>
                            </div>
                        </div>
                    </el-tab-pane>
                </el-tabs>
            </div>

            <div id="map-container"></div>
        </div>

        <!-- ç™»å½•å¼¹çª— -->
        <el-dialog v-model="showLogin" title="æ¬¢è¿ä½¿ç”¨ VV Maps" width="400px" center>
            <el-tabs v-model="loginTab">
                <el-tab-pane label="ç™»å½•" name="login">
                    <el-form :model="loginForm" label-position="top">
                        <el-form-item label="ç”¨æˆ·å">
                            <el-input v-model="loginForm.username" placeholder="è¯·è¾“å…¥ç”¨æˆ·å"></el-input>
                        </el-form-item>
                        <el-form-item label="å¯†ç ">
                            <el-input v-model="loginForm.password" type="password" placeholder="è¯·è¾“å…¥å¯†ç " show-password></el-input>
                        </el-form-item>
                    </el-form>
                </el-tab-pane>
                <el-tab-pane label="æ³¨å†Œ" name="register">
                    <el-form :model="registerForm" label-position="top">
                        <el-form-item label="ç”¨æˆ·å">
                            <el-input v-model="registerForm.username" placeholder="è¯·è¾“å…¥ç”¨æˆ·å"></el-input>
                        </el-form-item>
                        <el-form-item label="å¯†ç ">
                            <el-input v-model="registerForm.password" type="password" placeholder="è¯·è¾“å…¥å¯†ç " show-password></el-input>
                        </el-form-item>
                        <el-form-item label="ç¡®è®¤å¯†ç ">
                            <el-input v-model="registerForm.confirmPassword" type="password" placeholder="è¯·å†æ¬¡è¾“å…¥å¯†ç " show-password></el-input>
                        </el-form-item>
                    </el-form>
                </el-tab-pane>
            </el-tabs>
            <template #footer>
                <el-button @click="showLogin = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="loginTab === 'login' ? handleLogin() : handleRegister()">
                    {{ loginTab === 'login' ? 'ç™»å½•' : 'æ³¨å†Œ' }}
                </el-button>
            </template>
        </el-dialog>
    </div>

    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.4.15/vue.global.prod.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/element-plus/2.4.3/index.full.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/element-plus-icons-vue/2.3.1/global.iife.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <script>
        const { createApp, ref, onMounted } = Vue;
        const API_BASE = 'http://localhost:8080';

        const app = createApp({
            setup() {
                // çŠ¶æ€å˜é‡
                const isLoggedIn = ref(false);
                const username = ref('');
                const showLogin = ref(false);
                const loginTab = ref('login');
                const activeTab = ref('path');
                const calculating = ref(false);

                // åœ°å›¾ç›¸å…³
                let map = null;
                let routeLayer = null;
                let markersLayer = null;

                // è¡¨å•æ•°æ®
                const pathForm = ref({
                    start: '',
                    end: '',
                    modes: ['walk', 'bus', 'subway'] // é»˜è®¤é€‰ä¸­
                });
                const loginForm = ref({ username: '', password: '' });
                const registerForm = ref({ username: '', password: '', confirmPassword: '' });
                const nodeSearchInput = ref('');

                // æ•°æ®
                const allNodes = ref([]);
                const searchResults = ref([]);
                const pathResult = ref(null);

                // è·å–æ‰€æœ‰èŠ‚ç‚¹
                const fetchAllNodes = async () => {
                    try {
                        const response = await fetch(`${API_BASE}/api/nodes`);
                        const data = await response.json();
                        allNodes.value = data.nodes || [];
                        // åˆå§‹ä¸æ˜¾ç¤ºä»»ä½•èŠ‚ç‚¹ï¼Œåªæœ‰è·¯å¾„è§„åˆ’åæ‰æ˜¾ç¤ºç›¸å…³èŠ‚ç‚¹
                    } catch (e) {
                        console.error('è·å–èŠ‚ç‚¹å¤±è´¥:', e);
                        ElementPlus.ElMessage.error('è·å–èŠ‚ç‚¹æ•°æ®å¤±è´¥');
                    }
                };

                // è·å–äº¤é€šæ–¹å¼å¯¹åº”çš„é¢œè‰²
                const getModeColor = (mode) => {
                    const colors = {
                        'walk': '#67C23A',    // ç»¿è‰² - æ­¥è¡Œ
                        'bike': '#909399',    // ç°è‰² - éª‘è¡Œ
                        'car': '#409EFF',     // è“è‰² - é©¾è½¦
                        'bus': '#E6A23C',     // æ©™è‰² - å…¬äº¤
                        'subway': '#F56C6C'   // çº¢è‰² - åœ°é“
                    };
                    return colors[mode] || '#409EFF';
                };

                // åˆ›å»ºç®­å¤´è£…é¥°å™¨ (ç™¾åº¦åœ°å›¾é£æ ¼ - æ›´å°å·§å†…åµŒå¼ç®­å¤´)
                const createArrowDecorator = (latlngs, color) => {
                    const arrows = [];
                    for (let i = 0; i < latlngs.length - 1; i++) {
                        const start = latlngs[i];
                        const end = latlngs[i + 1];

                        // è®¡ç®—çº¿æ®µé•¿åº¦ï¼Œåªåœ¨è¾ƒé•¿çº¿æ®µä¸Šæ˜¾ç¤ºç®­å¤´
                        const distance = Math.sqrt(
                            Math.pow(end[0] - start[0], 2) + Math.pow(end[1] - start[1], 2)
                        );
                        if (distance < 0.001) continue; // è·³è¿‡å¤ªçŸ­çš„çº¿æ®µ

                        // è®¡ç®—ä¸­ç‚¹
                        const midLat = (start[0] + end[0]) / 2;
                        const midLng = (start[1] + end[1]) / 2;

                        // è®¡ç®—è§’åº¦
                        const angle = Math.atan2(end[0] - start[0], end[1] - start[1]) * 180 / Math.PI;

                        // åˆ›å»ºå°å·§çš„å†…åµŒç®­å¤´
                        const arrowIcon = L.divIcon({
                            className: 'route-arrow',
                            html: `<div style="
                                transform: rotate(${-angle + 90}deg);
                                width: 0;
                                height: 0;
                                border-left: 4px solid transparent;
                                border-right: 4px solid transparent;
                                border-bottom: 6px solid white;
                                filter: drop-shadow(0 0 1px rgba(0,0,0,0.3));
                            "></div>`,
                            iconSize: [8, 6],
                            iconAnchor: [4, 3]
                        });

                        arrows.push(L.marker([midLat, midLng], { icon: arrowIcon, interactive: false }));
                    }
                    return arrows;
                };

                // åœ¨åœ°å›¾ä¸Šç»˜åˆ¶è·¯çº¿ (ç™¾åº¦åœ°å›¾é£æ ¼)
                const drawRouteOnMap = (result) => {
                    if (!map || !routeLayer) return;
                    routeLayer.clearLayers();
                    markersLayer.clearLayers();

                    if (!result.segments || result.segments.length === 0) return;

                    // æ”¶é›†æ‰€æœ‰è·¯å¾„ç‚¹ç”¨äºç»˜åˆ¶å¹³æ»‘è·¯çº¿
                    const allPoints = [];
                    const segmentColors = [];

                    // æŒ‰äº¤é€šæ–¹å¼åˆ†æ®µç»˜åˆ¶è·¯çº¿
                    result.segments.forEach((seg, index) => {
                        const fromNode = result.path.find(n => n.id === seg.from_id);
                        const toNode = result.path.find(n => n.id === seg.to_id);

                        if (!fromNode || !toNode) return;

                        const segLatLngs = [[fromNode.lat, fromNode.lng], [toNode.lat, toNode.lng]];
                        const color = getModeColor(seg.used_mode);

                        // ç™¾åº¦åœ°å›¾é£æ ¼ï¼šæ·±è‰²è¾¹æ¡† + ä¸»è‰²å¡«å……
                        // å…ˆç»˜åˆ¶æ·±è‰²è¾¹æ¡†å±‚
                        const polylineBorder = L.polyline(segLatLngs, {
                            color: shadeColor(color, -30),
                            weight: 8,
                            opacity: 0.9,
                            lineCap: 'round',
                            lineJoin: 'round'
                        });

                        // å†ç»˜åˆ¶ä¸»è‰²çº¿æ¡
                        const polyline = L.polyline(segLatLngs, {
                            color: color,
                            weight: 5,
                            opacity: 1,
                            lineCap: 'round',
                            lineJoin: 'round'
                        });

                        routeLayer.addLayer(polylineBorder);
                        routeLayer.addLayer(polyline);

                        // æ·»åŠ æ–¹å‘ç®­å¤´
                        const arrows = createArrowDecorator(segLatLngs, color);
                        arrows.forEach(arrow => routeLayer.addLayer(arrow));

                        // æ·»åŠ è·¯æ®µå¼¹çª—ä¿¡æ¯
                        polyline.bindPopup(`
                            <div style="text-align:center; padding: 5px;">
                                <b>${getModeIcon(seg.used_mode)} ${getModeLabel(seg.used_mode)}</b><br>
                                <span style="color:#333;">${seg.from_name} â†’ ${seg.to_name}</span><br>
                                <span style="color:#888; font-size: 12px;">${formatDistance(seg.distance)} Â· ${formatTime(seg.time)}</span>
                            </div>
                        `);
                    });

                    // æ·»åŠ ä¸­é—´èŠ‚ç‚¹æ ‡è®° (å°åœ†ç‚¹æ ·å¼)
                    const middleNodes = result.path.slice(1, -1);
                    middleNodes.forEach((node, index) => {
                        const segIndex = Math.min(index, result.segments.length - 1);
                        const mode = result.segments[segIndex]?.used_mode || 'walk';
                        const color = getModeColor(mode);

                        // å°åœ†ç‚¹æ ‡è®°
                        const marker = L.circleMarker([node.lat, node.lng], {
                            radius: 4,
                            fillColor: '#fff',
                            color: color,
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 1
                        });
                        marker.bindPopup(`<b>${node.name}</b><br><span style="color:#666;">${getTypeLabel(node.type)}</span>`);
                        markersLayer.addLayer(marker);
                    });

                    // æ·»åŠ èµ·ç‚¹å’Œç»ˆç‚¹æ ‡è®° (ç™¾åº¦åœ°å›¾é£æ ¼å°åœ†ç‚¹+å›¾æ ‡)
                    if (result.path.length > 0) {
                        const startNode = result.path[0];
                        const endNode = result.path[result.path.length - 1];

                        // èµ·ç‚¹æ ‡è®° - ç»¿è‰²å°åœ†ç‚¹
                        const startMarker = L.marker([startNode.lat, startNode.lng], {
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `<div class="marker-start" style="position:relative;">
                                    <span style="font-size:14px;">èµ·</span>
                                    <div class="marker-pointer"></div>
                                </div>`,
                                iconSize: [24, 30],
                                iconAnchor: [12, 30]
                            }),
                            zIndexOffset: 1000
                        });
                        startMarker.bindPopup(`<b>èµ·ç‚¹</b><br>${startNode.name}`);
                        routeLayer.addLayer(startMarker);

                        // ç»ˆç‚¹æ ‡è®° - çº¢è‰²å°åœ†ç‚¹
                        const endMarker = L.marker([endNode.lat, endNode.lng], {
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `<div class="marker-end" style="position:relative;">
                                    <span style="font-size:14px;">ç»ˆ</span>
                                    <div class="marker-pointer"></div>
                                </div>`,
                                iconSize: [24, 30],
                                iconAnchor: [12, 30]
                            }),
                            zIndexOffset: 1000
                        });
                        endMarker.bindPopup(`<b>ç»ˆç‚¹</b><br>${endNode.name}`);
                        routeLayer.addLayer(endMarker);
                    }

                    // è°ƒæ•´åœ°å›¾è§†é‡
                    const allLatLngs = result.path.map(node => [node.lat, node.lng]);
                    const bounds = L.latLngBounds(allLatLngs);
                    map.fitBounds(bounds, { padding: [50, 50] });
                };

                // é¢œè‰²åŠ æ·±/å˜æµ…è¾…åŠ©å‡½æ•°
                const shadeColor = (color, percent) => {
                    const num = parseInt(color.replace('#', ''), 16);
                    const amt = Math.round(2.55 * percent);
                    const R = Math.max(Math.min((num >> 16) + amt, 255), 0);
                    const G = Math.max(Math.min((num >> 8 & 0x00FF) + amt, 255), 0);
                    const B = Math.max(Math.min((num & 0x0000FF) + amt, 255), 0);
                    return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
                };

                // åˆ‡æ¢äº¤é€šæ–¹å¼
                const toggleMode = (mode) => {
                    const index = pathForm.value.modes.indexOf(mode);
                    if (index > -1) {
                        pathForm.value.modes.splice(index, 1);
                    } else {
                        pathForm.value.modes.push(mode);
                    }
                };

                // è·¯å¾„è§„åˆ’
                const findPath = async () => {
                    if (!pathForm.value.start || !pathForm.value.end) {
                        ElementPlus.ElMessage.warning('è¯·é€‰æ‹©èµ·ç‚¹å’Œç»ˆç‚¹');
                        return;
                    }
                    if (pathForm.value.modes.length === 0) {
                        ElementPlus.ElMessage.warning('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§äº¤é€šæ–¹å¼');
                        return;
                    }

                    calculating.value = true;

                    try {
                        const response = await fetch(`${API_BASE}/api/path/find`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                start_id: pathForm.value.start,
                                end_id: pathForm.value.end,
                                modes: pathForm.value.modes
                            })
                        });
                        const data = await response.json();

                        if (data.found) {
                            pathResult.value = data;
                            drawRouteOnMap(data);
                            ElementPlus.ElMessage.success('è·¯å¾„è§„åˆ’æˆåŠŸï¼');
                        } else {
                            ElementPlus.ElMessage.warning(data.message || 'æœªæ‰¾åˆ°è·¯å¾„');
                            pathResult.value = null;
                        }
                    } catch (e) {
                        console.error('è·¯å¾„è§„åˆ’å¤±è´¥:', e);
                        ElementPlus.ElMessage.error('è·¯å¾„è§„åˆ’è¯·æ±‚å¤±è´¥');
                    } finally {
                        calculating.value = false;
                    }
                };

                // æœç´¢èŠ‚ç‚¹
                const searchNodesByName = async () => {
                    if (!nodeSearchInput.value) {
                        searchResults.value = [];
                        return;
                    }
                    try {
                        const response = await fetch(`${API_BASE}/api/nodes/search?q=${encodeURIComponent(nodeSearchInput.value)}`);
                        const data = await response.json();
                        searchResults.value = data.results || [];
                    } catch (e) {
                        console.error('æœç´¢å¤±è´¥:', e);
                    }
                };

                // èšç„¦èŠ‚ç‚¹
                const focusNode = (node) => {
                    if (map) {
                        map.setView([node.lat, node.lng], 16);

                        // æ˜¾ç¤ºå¼¹çª—
                        L.popup()
                            .setLatLng([node.lat, node.lng])
                            .setContent(`<b>${node.name}</b><br>${getTypeLabel(node.type)}`)
                            .openOn(map);
                    }
                };

                // èµ·ç‚¹/ç»ˆç‚¹æ”¹å˜æ—¶èšç„¦
                const onStartChange = (id) => {
                    const node = allNodes.value.find(n => n.id === id);
                    if (node && map) {
                        map.setView([node.lat, node.lng], 15);
                    }
                };
                const onEndChange = (id) => {
                    const node = allNodes.value.find(n => n.id === id);
                    if (node && map) {
                        map.setView([node.lat, node.lng], 15);
                    }
                };

                // ç™»å½•
                const handleLogin = async () => {
                    if (!loginForm.value.username || !loginForm.value.password) {
                        ElementPlus.ElMessage.warning('è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ');
                        return;
                    }
                    try {
                        const response = await fetch(`${API_BASE}/api/login`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(loginForm.value)
                        });
                        const data = await response.json();
                        if (response.ok) {
                            isLoggedIn.value = true;
                            username.value = loginForm.value.username;
                            showLogin.value = false;
                            ElementPlus.ElMessage.success('ç™»å½•æˆåŠŸ');
                        } else {
                            ElementPlus.ElMessage.error(data.error || 'ç™»å½•å¤±è´¥');
                        }
                    } catch (e) {
                        ElementPlus.ElMessage.error('ç™»å½•è¯·æ±‚å¤±è´¥');
                    }
                };

                // æ³¨å†Œ
                const handleRegister = async () => {
                    if (!registerForm.value.username || !registerForm.value.password) {
                        ElementPlus.ElMessage.warning('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                        return;
                    }
                    if (registerForm.value.password !== registerForm.value.confirmPassword) {
                        ElementPlus.ElMessage.warning('ä¸¤æ¬¡å¯†ç ä¸ä¸€è‡´');
                        return;
                    }
                    try {
                        const response = await fetch(`${API_BASE}/api/register`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                username: registerForm.value.username,
                                password: registerForm.value.password
                            })
                        });
                        const data = await response.json();
                        if (response.ok) {
                            ElementPlus.ElMessage.success('æ³¨å†ŒæˆåŠŸï¼Œè¯·ç™»å½•');
                            loginTab.value = 'login';
                            loginForm.value.username = registerForm.value.username;
                        } else {
                            ElementPlus.ElMessage.error(data.error || 'æ³¨å†Œå¤±è´¥');
                        }
                    } catch (e) {
                        ElementPlus.ElMessage.error('æ³¨å†Œè¯·æ±‚å¤±è´¥');
                    }
                };

                // é€€å‡ºç™»å½•
                const handleLogout = () => {
                    isLoggedIn.value = false;
                    username.value = '';
                    ElementPlus.ElMessage.success('å·²é€€å‡ºç™»å½•');
                };

                // æ ¼å¼åŒ–æ—¶é—´
                const formatTime = (seconds) => {
                    if (seconds < 60) return Math.round(seconds) + 'ç§’';
                    if (seconds < 3600) return Math.round(seconds / 60) + 'åˆ†é’Ÿ';
                    const hours = Math.floor(seconds / 3600);
                    const mins = Math.round((seconds % 3600) / 60);
                    return hours + 'å°æ—¶' + mins + 'åˆ†é’Ÿ';
                };

                // æ ¼å¼åŒ–è·ç¦»
                const formatDistance = (meters) => {
                    if (meters < 1000) return Math.round(meters) + 'ç±³';
                    return (meters / 1000).toFixed(1) + 'å…¬é‡Œ';
                };

                // è·å–ç±»å‹æ ‡ç­¾
                const getTypeLabel = (type) => {
                    const labels = {
                        'landmark': 'åœ°æ ‡',
                        'bus_stop': 'å…¬äº¤ç«™',
                        'subway_entrance': 'åœ°é“ç«™',
                        'road_node': 'è·¯å£'
                    };
                    return labels[type] || type;
                };

                // è·å–äº¤é€šæ–¹å¼æ ‡ç­¾
                const getModeLabel = (mode) => {
                    const labels = {
                        'walk': 'æ­¥è¡Œ',
                        'bike': 'éª‘è¡Œ',
                        'car': 'é©¾è½¦',
                        'bus': 'å…¬äº¤',
                        'subway': 'åœ°é“'
                    };
                    return labels[mode] || mode;
                };

                // è·å–äº¤é€šæ–¹å¼å›¾æ ‡
                const getModeIcon = (mode) => {
                    const icons = {
                        'walk': 'ğŸš¶',
                        'bike': 'ğŸš²',
                        'car': 'ğŸš—',
                        'bus': 'ğŸšŒ',
                        'subway': 'ğŸš‡'
                    };
                    return icons[mode] || 'ğŸ“';
                };

                // åˆå§‹åŒ–åœ°å›¾
                onMounted(() => {
                    // ä»¥éƒ‘å·é«˜æ–°åŒºä¸ºä¸­å¿ƒ
                    map = L.map('map-container').setView([34.82, 113.54], 14);

                    // ä½¿ç”¨ OpenStreetMap ç“¦ç‰‡ (ä¸ OSM åæ ‡ç³»ä¸€è‡´)
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        subdomains: ['a', 'b', 'c'],
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                        maxZoom: 19
                    }).addTo(map);

                    // åˆ›å»ºå›¾å±‚ç»„
                    markersLayer = L.layerGroup().addTo(map);
                    routeLayer = L.layerGroup().addTo(map);

                    // è·å–èŠ‚ç‚¹æ•°æ®
                    fetchAllNodes();
                });

                return {
                    isLoggedIn, username, showLogin, loginTab, activeTab,
                    pathForm, loginForm, registerForm,
                    allNodes, searchResults, pathResult,
                    calculating, nodeSearchInput,
                    toggleMode, findPath, searchNodesByName, focusNode,
                    onStartChange, onEndChange,
                    handleLogin, handleRegister, handleLogout,
                    formatTime, formatDistance, getTypeLabel, getModeLabel, getModeIcon
                };
            }
        });

        // æ³¨å†Œå›¾æ ‡
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
            app.component(key, component);
        }

        app.use(ElementPlus);
        app.mount('#app');
    </script>
</body>
</html>
